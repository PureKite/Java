## 객체지향 프로그래밍2

---
### ❓ 상속(inheritance)
- 상속의 정의와 장점
  - 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
  - 상속을 통해 클래스를 작성하면 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이
    - 즉, 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여
  - 자바에서 상속을 구현하는 방법
    - 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 씀
    ```agsl
    class Child extends Parent{
        // ...
    }
    ```
  - 조상 클래스 : 부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스
  - 자손 클래스 : 자식(child) 클래스, 하위(sub) 클래스, 파생된(derived) 클래스
  - 상속계층도(class hierarchy) : 클래스 간의 상속관계를 그림으로 표현한 것(p.223 참고)
  - 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 가짐
    - 즉, 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나게 된다.
  - 상속을 받는다는 것 = 조상 클래스를 확장(extend)한다는 의미로 해석 가능
  - 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속됨
  - 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많음
  - 클래스 간의 관계에서 형재 관계와 같은 것은 없음. 부모와 자식의 관계(상속 관계)만이 존재
  - 조상 클래스만 변경해도 모든 자손 클래스에, 자손의 자손 클래스에까지 영향을 미치기 때문에, 클래스간의 상속관계를 맺어 주면 클래스들의 공통적인 부분은 조상 클래스에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리하면 됨
    - 즉, 각 클래스의 코드가 적어져서 관리가 쉬워짐
      - 코드의 중복이 많아지면 유지보수가 어려워지고 일관성을 유지하기 어려움
  - 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성
- 클래스간의 관계 - 포함관계
  - 상속이외에도 클래스를 재사용하는 또 다른 방법 : 클래스 간에 '포함(Composite)관계'를 맺어 주는 것
    - 클래스 간에 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
  ```agsl
  class Point{
    int x;
    int y;
  }
  class Circle{
    Point c = new Point(); 
    int r;
  }
  ```
    - 한 클래스를 작성하는 데 다른 클래스를 멤버변수로 정의하여 포함시키는 것
  - 하나의 거대한 클래스를 작성하는 거보다 단위별로 여러 개의 클래스를 작성한 다음, 단위 클래스들을 포홤관계로 재사용
- 클래스간의 관계 결정하기
  - 상속관계 : '~은 ~이다.(is-a)'
  - 포홤관계 : '~은 ~을 가지고 있다.(has-a)'
- 단일상속(single inheritance)
  - 하나 이상의 클래스로부터 상속을 받을 수 없음
    - C++에서는 여러 클래스로부터 상속받는 다중상속을 허용하지만 자바에서는 단일 상속만을 허용하기 때문에
    - 다중상속 장점
      - 다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성
    - 다중상속 단점
      - 클래스간의 관계가 매우 복잡해짐
      - 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 없음
- Object클래스 - 모든 클래스의 조상
  - 모든 상속계층도의 최상의위에는 Object클래스가 위치  
    - Object클래스는 모든 클래스 상속계층도의 제일 위에 위치하는 조상클래스
    - 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함
  - 자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있음
    - toString(), equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용할 수 있었던 이유

### ❓ 오버라이딩(overriding)
- 오버라이딩이란?
  - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
    - 자손 클래스 자신에 맞게 변경해야하는 경우
  ```agsl
  class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x :" + x + ", y : " + y;
    }
  }
   class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        return "x :" + x + ", y : " + y + ", z : " + z;
    }
  }
  ```
- 오버라이딩의 조건
  - 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야함
    - 이름이 같아야 함
    - 매개변수가 같아야 함
    - 리턴타입이 같아야함
  - 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경 가능
    1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 가능
       - 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야함
       - 대부분의 경우 같은 범위의 접근 제어자 사용
       - 접근 제어자의 접근범위를 넓은 것에서 좁은 것 순으로 나열
         - public, protected, (default), private
    2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
       - 주의할 점 : 단순히 선언된 예외의 개수의 문제가 아님
         - Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있음
  - 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없음
- 오버로딩 vs 오버라이딩
  - 오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new)
  - 오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify)
- super
  - 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
  - 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때는 super를 사용해서 구별
  - 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고 super와 this는 근본적으로 같음
  - 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 됨
    - static메서드(클래스메서드)는 인스턴스와 관련이 없음 => this와 마찬가지로 static메서드에서는 사용할 수 없음
  - 변수만이 아니라 메서드 역시 super를 써서 호출 가능
  - 특히 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에 super 사용
  ```agsl
  class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x :" + x + ", y : " + y;
    }
  }
   class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        // return "x :" + x + ", y : " + y + ", z : " + z;
        return super.getLocation() + ",z :" + z; // 조상의 메서드 호출 
    }
  }
- super() - 조상 클래스의 생성자
  - this()와 마찬가지로 super() 역시 생성자
  - this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용
  - 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스 생성
    - 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것
  - 조상 클래스 멤버의 생성과 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 함
  - 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유
    - 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야함
  - 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복
    - 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝이 남
    - Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야함
      - 그렇지 않으면 컴파일러는 생성자의 첫 줄에 'super();'를 자동적으로 추가
  - 인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요한 일
    1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
    2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

### ❓ package와 import
- package
  - 패키지란 클래스의 묶음
  - 패키지에는 클래스 또는 인터페이스를 포함 시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리
  - 같은 이름의 클래스일지라도 서로 다른 패키지에 존재하는 것이 가능
  - 자신만의 패키지 체계를 유지함으로써 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있음
  - 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리
  - 디렉토리가 하위 디렉토리를 가질 수 있는 것처럼, 패키지도 다른 패키지를 포함할 수 있으며 점 '.'으로 구분
    - 점(.)을 구분자로 하여 계층구조 구성
- 패키지의 선언
  - package 패키지명;
  - 하나의 소스파일에서 주석과 공백을 제외한 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
  - 모든 클래스는 반드시 하나의 패키지에 속해야함
  - 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는?
    - 자바에서 기본적으로 제공하는 '이름없는 패키지(unnamed package)' 때문
  - 패키지의 루트 디렉토리
    - 클래스패츠(classpath)
- import
  - 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것
  - 컴파일 시에 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여줌
  - import문은 프로그램의 성능에 전혀 영향을 미치지않음
    - import문을 많이 사용함녀 컴파일 시간이 아주 조금 더 걸릴 뿐
- import문의 선언
  - 모든 소스파일(.java)에서 import문은 package문 다음에, 그리고 클래스 선언 문 이전에 위치
    1. package문
    2. import문
    3. 클래스 선언
  - import문을 선언하는 방법
    - import 패키지명.클래스명;
    - import 패키지명.*;
  - 같은 패키지에서 여러 개의 클래스가 사용될 때, import문을 여러 번사용하는 대신 '패키지명.*'을 이용해 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용할 수 있음
    - 실행 시 성능상의 차이는 전혀 없음
    - import하는 패키지의 수가 많을 때는 어느 클래스가 어느 패키지에 속하는지 구별하기 어렵다는 단점
    - 클래스의 이름 대신 *를 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아님
      - 얘) import java.util.*; import java.text.*; => import java.*;X
  - import문으로 패키지를 지정하지 않으면 모든 클래스이름 앞에 패키지명을 반드시 붙여야함

### ❓ 제어자(modifier)
- 제어자란
  - 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미 부여
  - 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능
    - 접근 제어자는 한 번에 네 가지 중 하나만 선택 사용
- 종류
  - 접근 제어자 : public, protected, default, private
  - 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
- static - 클래스의 공통적인
  - '클래스의' 또는 '공통적인'의 의미
  - 인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지
  - 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 가짐
    - 하나의 변수를 모든 인스턴스가 공유하기 때문
    - static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용 가능
  - staic이 사용될 수 있는 곳 : 멤버변수, 메서드, 초기화 블럭
  - 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 됨
    - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능
    - 클래스가 메모리에 로드될 때 생성
  - 메서드
    - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 됨
    - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없음
- final - 마지막의, 변경될 수 없는
  - '마지막의' 또는 '변경될 수 없는'의 의미
  - 거의 모든 대상에 사용될 수 있음
  - final이 사용될 수 있는 곳 : 클래스, 메서드, 멤버변수, 지역변수
  - 클래스
    - 변경될 수 없는 클래스 확장될 수 없는 클래스가 됨
    - final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음
  - 메서드
    - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없음
  - 멤버변수, 지역변수
    - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 됨
- 생성자를 이용한 final 멤버변수 초기화
  - final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있음
  - 클래스 내에 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것
    - 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능
- abstract - 추상의, 미완성의
  - '미완성'의 의미
  - abstract가 사용될 수 있는 곳 - 클래스, 메서드
  - 클래스
    - 클래스 내에 추상메서드가 선언되어 있음을 의미
  - 메서드
    - 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알림
- 접근 제어자(access modifier)
  - 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
  - 접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지 않음
  - 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻함
  - 접근 제어자가 사용될 수 있는 곳 : 클래스, 멤버변수, 메서드, 생성자
  - private : 같은 클래스 내에서만 접근 가능
  - default : 같은 패키지 내에서만 접근 가능
  - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능
  - public : 접근 제한이 전혀 없음
  - 접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 나열
    - public > protected > default > private
  - 사용가능한 접근 제어자
    - 클래스 : public, (default)
    - 메서드, 멤버변수 : public, protected, (default), private
    - 지역변수 : 없음
- 접근 제어자를 이용한 캡슐화
  - 접근 제어자를 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해서
    - 외부에서 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
      - 데이터가 유효한 값을 유지하도록, 또는 비밀번화와 같은 데이터를 외부에서 함부로 변경하지 못하도록
        => 데이터 감추기(data hiding)이며 객체지향개념의 캡슐화에 해당하는 내용
- 생성자의 접근 제어자
  - 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있음
  - 보통 생성자의 접근 제어자는 클래스의 접근제어자와 같지만, 다르게 지정할 수도 있음
- 제어자(modifier)의 조합
  - 사용가능한 제어자
    - 클래스 : public, (default), final, abstract
    - 메서드 : 모든 접근 제어자, final, abstract, static
    - 멤버변수 : 모든 접근 제어자, final, static
    - 지역변수 : final
  - 제어자를 조합해서 사용할 때 주의해야 할 사항
    1. 메서드에 static과 abstract를 함께 사용할 수 없음
       - static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문
    2. 클래스에 abstract와 final을 동시에 사용할 수 없음
       - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문
    3. abstract메서드의 접근 제어자가 private일 수 없음
       - abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문
    4. 메서드에 private과 final을 같이 사용할 필요는 없음
       - 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문
       - 둘 중 하나만 사용해도 의미가 충분

### ❓ 다형성(polymorphism)
- 다형성이란?
  - '여러 가지 형태를 가질 수 있는 능력'을 의미
  - 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현
    - 구체적으로 말하면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함
    ```agsl
    Tv c = new Tv();
    CaptionTv c = new CaptionTv();
    // 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통
    
    CaptionTv c = new CaptionTv();
    Tv t = new CaptionTv();
    // Tv와 CaptionTv클래스가 서로 상속관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능
    // 이 때 참조변수 t로는 CaptionTv인스턴스의 모든 멤버를 사용할 수 없음
    // Tv타입의 참조변수로는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용할 수 있음
  
    // 즉, 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐
    
    CaptionTv c = new Tv(); // 컴파일에러 발생
    // 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문에 허용하지 않음
    ```
- 참조변수의 형변환
  - 기본형 변수와 같이 참조변수도 형변환 가능
    - 단, 서로 상속관계에 있는 클래스사이에서만 가능
  - 다운캐스팅(Down-casting) : 조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것(형변환 생략불가)
    - 작은 자료형에서 큰 자료형의 형변환은 생략 가능
  - 업캐스팅(Up-casting) : 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것(형변환 생략가능)
  - 참조변수간의 형변환 역시 캐스트연산자 사용, 괄호()안에 변환하고자 하는 타입의 이름(클래스명) 적어주면 됨
  - 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않음
    - 참조변수의 형변화를 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐
- instanceof연산자
  - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자 사용
  - 주로 조건문에 사용, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치
    - ex) Car c 일 때, if (c instanceof FireEngine)
  - 연산의 결과 : boolean값인 true, false 중의 하나로 반환
    - true : 참조변수가 검사한 타입으로 형변환이 가능하다는 것








### ❗ 회독
|  1회독  | 2회독  | 3회독  | 4회독  |  5회독  |
|:-----:|:----:|:----:|:----:|:-----:|
|   ⭕   |