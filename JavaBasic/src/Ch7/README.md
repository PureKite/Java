## 객체지향 프로그래밍2

---
### ❓ 상속(inheritance)
- 상속의 정의와 장점
  - 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
  - 상속을 통해 클래스를 작성하면 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이
    - 즉, 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여
  - 자바에서 상속을 구현하는 방법
    - 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 씀
    ```agsl
    class Child extends Parent{
        // ...
    }
    ```
  - 조상 클래스 : 부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스
  - 자손 클래스 : 자식(child) 클래스, 하위(sub) 클래스, 파생된(derived) 클래스
  - 상속계층도(class hierarchy) : 클래스 간의 상속관계를 그림으로 표현한 것(p.223 참고)
  - 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 가짐
    - 즉, 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나게 된다.
  - 상속을 받는다는 것 = 조상 클래스를 확장(extend)한다는 의미로 해석 가능
  - 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속됨
  - 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많음
  - 클래스 간의 관계에서 형재 관계와 같은 것은 없음. 부모와 자식의 관계(상속 관계)만이 존재
  - 조상 클래스만 변경해도 모든 자손 클래스에, 자손의 자손 클래스에까지 영향을 미치기 때문에, 클래스간의 상속관계를 맺어 주면 클래스들의 공통적인 부분은 조상 클래스에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리하면 됨
    - 즉, 각 클래스의 코드가 적어져서 관리가 쉬워짐
      - 코드의 중복이 많아지면 유지보수가 어려워지고 일관성을 유지하기 어려움
  - 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성
- 클래스간의 관계 - 포함관계
  - 상속이외에도 클래스를 재사용하는 또 다른 방법 : 클래스 간에 '포함(Composite)관계'를 맺어 주는 것
    - 클래스 간에 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
  ```agsl
  class Point{
    int x;
    int y;
  }
  class Circle{
    Point c = new Point(); 
    int r;
  }
  ```
    - 한 클래스를 작성하는 데 다른 클래스를 멤버변수로 정의하여 포함시키는 것
  - 하나의 거대한 클래스를 작성하는 거보다 단위별로 여러 개의 클래스를 작성한 다음, 단위 클래스들을 포홤관계로 재사용
- 클래스간의 관계 결정하기
  - 상속관계 : '~은 ~이다.(is-a)'
  - 포홤관계 : '~은 ~을 가지고 있다.(has-a)'
- 단일상속(single inheritance)
  - 하나 이상의 클래스로부터 상속을 받을 수 없음
    - C++에서는 여러 클래스로부터 상속받는 다중상속을 허용하지만 자바에서는 단일 상속만을 허용하기 때문에
    - 다중상속 장점
      - 다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성
    - 다중상속 단점
      - 클래스간의 관계가 매우 복잡해짐
      - 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 없음
- Object클래스 - 모든 클래스의 조상
  - 모든 상속계층도의 최상의위에는 Object클래스가 위치  
    - Object클래스는 모든 클래스 상속계층도의 제일 위에 위치하는 조상클래스
    - 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함
  - 자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있음
    - toString(), equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용할 수 있었던 이유

### ❓ 오버라이딩(overriding)
- 오버라이딩이란?
  - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
    - 자손 클래스 자신에 맞게 변경해야하는 경우
  ```agsl
  class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x :" + x + ", y : " + y;
    }
  }
   class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        return "x :" + x + ", y : " + y + ", z : " + z;
    }
  }
  ```
- 오버라이딩의 조건
  - 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야함
    - 이름이 같아야 함
    - 매개변수가 같아야 함
    - 리턴타입이 같아야함
  - 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경 가능
    1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 가능
       - 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야함
       - 대부분의 경우 같은 범위의 접근 제어자 사용
       - 접근 제어자의 접근범위를 넓은 것에서 좁은 것 순으로 나열
         - public, protected, (default), private
    2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
       - 주의할 점 : 단순히 선언된 예외의 개수의 문제가 아님
         - Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있음
  - 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없음
- 오버로딩 vs 오버라이딩
  - 오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new)
  - 오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify)
- super
  - 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
  - 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때는 super를 사용해서 구별
  - 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고 super와 this는 근본적으로 같음
  - 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 됨
    - static메서드(클래스메서드)는 인스턴스와 관련이 없음 => this와 마찬가지로 static메서드에서는 사용할 수 없음
  - 변수만이 아니라 메서드 역시 super를 써서 호출 가능
  - 특히 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에 super 사용
  ```agsl
  class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x :" + x + ", y : " + y;
    }
  }
   class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        // return "x :" + x + ", y : " + y + ", z : " + z;
        return super.getLocation() + ",z :" + z; // 조상의 메서드 호출 
    }
  }
- super() - 조상 클래스의 생성자
  - this()와 마찬가지로 super() 역시 생성자
  - this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용
  - 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스 생성
    - 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것
  - 조상 클래스 멤버의 생성과 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 함
  - 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유
    - 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야함
  - 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복
    - 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝이 남
    - Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야함
      - 그렇지 않으면 컴파일러는 생성자의 첫 줄에 'super();'를 자동적으로 추가
  - 인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요한 일
    1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
    2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

### ❓ package와 import
- package
  - 패키지란 클래스의 묶음
  - 패키지에는 클래스 또는 인터페이스를 포함 시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리
  - 같은 이름의 클래스일지라도 서로 다른 패키지에 존재하는 것이 가능
  - 자신만의 패키지 체계를 유지함으로써 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있음
  - 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리
  - 디렉토리가 하위 디렉토리를 가질 수 있는 것처럼, 패키지도 다른 패키지를 포함할 수 있으며 점 '.'으로 구분
    - 점(.)을 구분자로 하여 계층구조 구성
- 패키지의 선언
  - package 패키지명;
  - 하나의 소스파일에서 주석과 공백을 제외한 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
  - 모든 클래스는 반드시 하나의 패키지에 속해야함
  - 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는?
    - 자바에서 기본적으로 제공하는 '이름없는 패키지(unnamed package)' 때문
  - 패키지의 루트 디렉토리
    - 클래스패츠(classpath)
- import
  - 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것
  - 컴파일 시에 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여줌
  - import문은 프로그램의 성능에 전혀 영향을 미치지않음
    - import문을 많이 사용함녀 컴파일 시간이 아주 조금 더 걸릴 뿐
- import문의 선언
  - 모든 소스파일(.java)에서 import문은 package문 다음에, 그리고 클래스 선언 문 이전에 위치
    1. package문
    2. import문
    3. 클래스 선언
  - import문을 선언하는 방법
    - import 패키지명.클래스명;
    - import 패키지명.*;
  - 같은 패키지에서 여러 개의 클래스가 사용될 때, import문을 여러 번사용하는 대신 '패키지명.*'을 이용해 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용할 수 있음
    - 실행 시 성능상의 차이는 전혀 없음
    - import하는 패키지의 수가 많을 때는 어느 클래스가 어느 패키지에 속하는지 구별하기 어렵다는 단점
    - 클래스의 이름 대신 *를 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아님
      - 얘) import java.util.*; import java.text.*; => import java.*;X
  - import문으로 패키지를 지정하지 않으면 모든 클래스이름 앞에 패키지명을 반드시 붙여야함

### ❓ 제어자(modifier)
- 제어자란
  - 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미 부여
  - 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능
    - 접근 제어자는 한 번에 네 가지 중 하나만 선택 사용
- 종류
  - 접근 제어자 : public, protected, default, private
  - 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
- static - 클래스의 공통적인
  - '클래스의' 또는 '공통적인'의 의미
  - 인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지
  - 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 가짐
    - 하나의 변수를 모든 인스턴스가 공유하기 때문
    - static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용 가능
  - staic이 사용될 수 있는 곳 : 멤버변수, 메서드, 초기화 블럭
  - 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 됨
    - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능
    - 클래스가 메모리에 로드될 때 생성
  - 메서드
    - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 됨
    - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없음
- final - 마지막의, 변경될 수 없는
  - '마지막의' 또는 '변경될 수 없는'의 의미
  - 거의 모든 대상에 사용될 수 있음
  - final이 사용될 수 있는 곳 : 클래스, 메서드, 멤버변수, 지역변수
  - 클래스
    - 변경될 수 없는 클래스 확장될 수 없는 클래스가 됨
    - final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음
  - 메서드
    - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없음
  - 멤버변수, 지역변수
    - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 됨
- 생성자를 이용한 final 멤버변수 초기화
  - final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화 되도록 할 수 있음
  - 클래스 내에 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것
    - 이 기능을 활용하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능
- abstract - 추상의, 미완성의
  - '미완성'의 의미
  - abstract가 사용될 수 있는 곳 - 클래스, 메서드
  - 클래스
    - 클래스 내에 추상메서드가 선언되어 있음을 의미
  - 메서드
    - 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알림
- 접근 제어자(access modifier)
  - 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
  - 접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지 않음
  - 접근 제어자가 지정되어 있지 않다면, 접근 제어자가 default임을 뜻함
  - 접근 제어자가 사용될 수 있는 곳 : 클래스, 멤버변수, 메서드, 생성자
  - private : 같은 클래스 내에서만 접근 가능
  - default : 같은 패키지 내에서만 접근 가능
  - protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능
  - public : 접근 제한이 전혀 없음
  - 접근 범위가 넓은 쪽에서 좁은 쪽의 순으로 나열
    - public > protected > default > private
  - 사용가능한 접근 제어자
    - 클래스 : public, (default)
    - 메서드, 멤버변수 : public, protected, (default), private
    - 지역변수 : 없음
- 접근 제어자를 이용한 캡슐화
  - 접근 제어자를 사용하는 이유
    - 외부로부터 데이터를 보호하기 위해서
    - 외부에서 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
      - 데이터가 유효한 값을 유지하도록, 또는 비밀번화와 같은 데이터를 외부에서 함부로 변경하지 못하도록
        => 데이터 감추기(data hiding)이며 객체지향개념의 캡슐화에 해당하는 내용
- 생성자의 접근 제어자
  - 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있음
  - 보통 생성자의 접근 제어자는 클래스의 접근제어자와 같지만, 다르게 지정할 수도 있음
- 제어자(modifier)의 조합
  - 사용가능한 제어자
    - 클래스 : public, (default), final, abstract
    - 메서드 : 모든 접근 제어자, final, abstract, static
    - 멤버변수 : 모든 접근 제어자, final, static
    - 지역변수 : final
  - 제어자를 조합해서 사용할 때 주의해야 할 사항
    1. 메서드에 static과 abstract를 함께 사용할 수 없음
       - static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문
    2. 클래스에 abstract와 final을 동시에 사용할 수 없음
       - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고 abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문
    3. abstract메서드의 접근 제어자가 private일 수 없음
       - abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없기 때문
    4. 메서드에 private과 final을 같이 사용할 필요는 없음
       - 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문
       - 둘 중 하나만 사용해도 의미가 충분

### ❓ 다형성(polymorphism)
- 다형성이란?
  - '여러 가지 형태를 가질 수 있는 능력'을 의미
  - 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현
    - 구체적으로 말하면, 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함
    ```agsl
    Tv c = new Tv();
    CaptionTv c = new CaptionTv();
    // 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통
    
    CaptionTv c = new CaptionTv();
    Tv t = new CaptionTv();
    // Tv와 CaptionTv클래스가 서로 상속관계에 있을 경우, 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능
    // 이 때 참조변수 t로는 CaptionTv인스턴스의 모든 멤버를 사용할 수 없음
    // Tv타입의 참조변수로는 CaptionTv인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용할 수 있음
  
    // 즉, 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐
    
    CaptionTv c = new Tv(); // 컴파일에러 발생
    // 실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문에 허용하지 않음
    ```
- 참조변수의 형변환
  - 기본형 변수와 같이 참조변수도 형변환 가능
    - 단, 서로 상속관계에 있는 클래스사이에서만 가능
  - 다운캐스팅(Down-casting) : 조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것(형변환 생략불가)
    - 작은 자료형에서 큰 자료형의 형변환은 생략 가능
  - 업캐스팅(Up-casting) : 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것(형변환 생략가능)
  - 참조변수간의 형변환 역시 캐스트연산자 사용, 괄호()안에 변환하고자 하는 타입의 이름(클래스명) 적어주면 됨
  - 형변환은 참조변수의 타입을 변환하는 것이지 인스턴스를 변환하는 것은 아니기 때문에 참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않음
    - 참조변수의 형변화를 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것뿐
- instanceof연산자
  - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof연산자 사용
  - 주로 조건문에 사용, instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입(클래스명)이 피연산자로 위치
    - ex) Car c 일 때, if (c instanceof FireEngine)
  - 연산의 결과 : boolean값인 true, false 중의 하나로 반환
    - true : 참조변수가 검사한 타입으로 형변환이 가능하다는 것
- 참조변수와 인스턴스의 연결
  - 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우
    - 조상타입의 참조변수를 사용했을 때 : 조상 클래스에 선언된 멤버변수 사용
    - 자손타입의 참조변수를 사용했을 때 : 자손 클래스에 선언된 멤버변수 사용
    - 즉, 참조변수의 타입에 따라 달라짐
  - 중복 정의되지 않은 경우에는 차이가 없음
  - 메서드였다면
    - 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우
      - 참조 변수의 타입에 관계없이 항상 실제 인스턴스의 메서드(오버라이딩된 메서드)가 호출됨
- 매개변수의 다형성
  - 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용
  - 예제
  ```agsl
  // 예제 클래스
  class Product{
    int price;  // 제품의 가격
    int bonusPoint;  // 제품구매 시 제공하는 보너스 점수
  }
  class Tv extends Product{}
  class Computer extends Product{}
  class Audio extends Product {}
  
  class Buyer{  // 고객, 물건을 사는 사람
    int money = 1000; // 소유금액
    int bonusPoint = 0; // 보너스점수
  }
  
  // Tv를 구입하는 기능의 메서드
  void buy(Tv t){
    // Buyer가 가진 돈에서 Tv의 가격만큼 뺌
    money = money - t.price;
    // Buyer의 보너스점수에 제품의 보너스점수 더함
    bonusPoint = bonusPoint + t.bonusPoint;
  }
  // 하지만 이렇게하면 Tv밖에 살수 없음
  
  // 다른 제품의 메서드도 다 추가해주어야함
  void buy(Computer c) {...}
  
  // !!메서드의 매개변수에 다형성을 적용하면 하나의 메서드로 해결
  void buy(Product p){
    money = money - p.price;
    bonusPoint = bousPoint + p.bonusPoint;
  }
  // 매개변수가 Product타입의 참조변수라는 것 => 메서드의 매개변수로 Product클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 뜻
  // Product 클래스에 price와 bonusPoint가 선언되어 있기 때문에 참조변수 p로 인스턴스의 price와 bonusPoint 사용 가능
  ```
- 여러 종류의 객체를 하나의 배열로 다루기
  - 조상타입의 참조변수 배열르 사용하면 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있음
  - 예제
    ```agsl
    Product p1 = new Tv();
    Product p2 = new Computer();
    Product p3 = new Audio();
    // 위의 코드를 Product타입의 참조변수 배열로 변경 가능
    Product p[] = new Product[3];
    p[0] = new Tv();
    p[1] = new Computer();
    p[2] = new Audio();
    ```
  - 묶어서 다루고자하는 객체들의 상속관계를 따져서 가장 가까운 공통조상 클래스 타입의 참조변수 배열을 생성해서 객체들을 저장 가능
    - 예제
      ```agsl
      class Buyer{
         // ...     
          Product[] item = new Product[10];

          void buy(Product p){
              // ... 
              item[i++] = p;
          }
      }
      ```
      ➕ 배열의 크기를 모를때
        - Vector 클래서 사용
          - Vector 클래스
            - 내부적으로 Object타입의 배열을 가지고 있어서 이 배열에 객체를 추가하거나 제거할 수 있게 작성
            - 배열의 크기를 알아서 관리해주기 때문에 저장할 인스턴스의 개수에 신경쓰지 않아도 됨

### ❓ 추상클래스(abstract class)
- 추상클래스란?
  - 미완성 설계도에 비유
    - 미완성 설계도 : 단어의 뜻 그대로 완성되지 못한 채로 남겨진 설계도
  - 클래스가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라, 단지 미완성 메서드(추상메서드)를 포함하고 있다는 의미
  - 추상클래서 인스턴스 생성할 수 없음 => 상속을 통해서 자손클래스에 의해서만 완성
  - 추상클래스 자체로는 클래스로서의 역할을 다 못하지만, 새로운 클래스를 작성하는데 바탕이 되는 조상클래스로 중요
    - 새로운 클래스를 작성할 때 아무것도 없는 상태보다 추상 상태가 더 나음
  - 키워드 'abstract' 붙이면 됨
    - 클래스의 선언부의 abstract를 보고 이 클래스에는 추상메서드가 있으니 상속을 통해서 구현해주어야한다는 것을 쉽게 알 수 있음
    - 형식 : abstract class 클래스이름
  - 추상클래스에도 생성자가 있으며 멤버변수와 메서드도 가질 수 있음
    - 추상 메서드를 포함한다는 것 외에는 일반클래스와 다르지 않음
- 추상메서드(abstract method)
  - 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨둔 것
    - 메서드의 이름, 메서드의 작업에 필요한 매개변수, 어떤 타입의 값 반환을 결정 => 선언부가 중요
  - 죽, 설계만 해 놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드
    - 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에
  - 조상 클래스에서는 선언부만 작성하고 주석으로 어떤 기능을 수행할 목적으로 작성되었는지 알려주고 실제 내용은 상속받는 클래스에서 구현하도록 비워 두는 것
    - 자손 클래스는 오버라이딩을 통해 조상의 추상 메서드를 상황에 맞게 구현
      - 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 => 추상클래스로 지정
  - 형식 : /* 어떤 기능을 수행할 목적 */ abstract 리턴타입 메서드이름();
- 추상클래스의 작성
  - 여러 클래스에 공통적으로 사용될 수 잇는 클래스를 바로 작성하는 경우
  - 기존의 클래스의 공통적인 부분을 뽑아서 추상클래스로 만들어 상속하도록 하는 경우
  - 상속 : 자손 클래스를 만드는데 조상 클래스를 사용하는 것 <-> 추상화 : 기존의 클래스의 공통부분을 뽑아내서 조상 클래스르 만드는 것
    - 상속 계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화의 정도가 심해짐
    - 상속 계층도를 따라 올라갈수록 클래스는 추상회의 정도가 심해짐
    - 즉, 상속계층도를 따라 내려 갈수록 세분화되며, 올갈수록 공통요소만 남게 됨
  - 굳이 abstract를 붙여서 추상메서드로 선언하는 이유는 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서
    - 추상메서드로 정의되어 있지 않고 빈 몸통만 가지도록 정의되어 있다면 상속받는 자손 클래스에서는 이 메서드들이 온전히 구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하지 않을 수도 있기 때문
    - abstract를 사용해 정의하면 자손 클래스를 작성할 때 추상메서드이므로 내용을 구현해주어야한다는 사실로 인식하고 자신의 클래스에 앎자게 구현할 것

### ❓ 인터페이스(interface)
- 인터페이스란?
  - 일종의 추상클래스
  - 추상클래스처럼 추상메서드를 갖지만 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드
    - 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외에 다른 어떠한 요소도 허용하지 않음
  - 추상클래스 : '미완성 설계도', 인터페이스 : '기본 설계도'
    - 기본 설계도 : 구현된 것은 아무것도 없는 밑그림
  - 완성되지 않은 불완전한 것 => 다른 클래스를 작성하는데 도움 줄 목적
- 인터페이스의 작성
  - 인터페이스를 작성하는 것 = 클래스를 작성하는 것
  - 다만, 키워드 = class X, interface 사용
  - interface에도 클래스와 같이 접근제어자로 public or default 사용
  - 형식
    ```agsl
    interface 인터페이스 \이름{
        public static final 타입 상수이름 = 값;
        public abstract 메서드이름(매개변수목록);
    }
    ```
  - 인터페이스의 멤버 제약사항
    - 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있음
    - 모든 메서드는 public abstract이어야 하며, 이를 생략할 수 있음
    - 인터페이스에 정의된 모든 멤버에 예외없이 적용되는 사항이기 때문에 제어자를 생략할 수 있는 것(편의상, 컴파일 시 컴파일러가 자동 추가)
- 인터페이스의 상속
  - 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 여러 개의 인터페이스로부터 상속을 받는 것이 가능
  - 클래스의 상속과 마찬가지로 자손 인터페이스는 조상 인터페이스에 정의된 멤버를 모두 상속받음
- 인터페이스의 구현
  - 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야함
    - 키워드 : 'implements'
    - 형식 : class 클래스이름 implements 인터페이스이름{}
  - 인터페이스의 메서드 중 일부만 구현한다면 추상클래스로 선언
  - 상속과 구현을 동시에 가능
    - 예시 : class Fighter extends Unit implements Fightable{}
  - 인터페이스 이름에는 ~able(할 수 있는)로 끝나는 것이 많음
    - 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서
- 인터페이스를 이용한 다중상속
  - 인터페이스는 상수만 정의할 수 있으므로 조상클래스의 멤버변수와 충돌하는 경우는 극히 드묾
  - 추상메서드는 구현내용이 전혀 없으므로 조상 클래스의 메서드와 선언부가 일치하는 경우 => 조상 클래스 쪽의 메서드를 상속받으면 되므로 문제되지 않음
    - 상속받는 멤버의 충돌은 피할 수 있지만, 다중상속의 장점을 잃게 됨
    - 두 개의 클래스로부터 상속을 받아야 할 상황 => 비중이 높은 쪽을 상속, 다른 한쪽은 클래스 내부에 멤버를 포함시키는 방식으로 처리 or 어느 한쪽의 필요한 부분을 뽑아서 인터페이스로 만든 다음 구현
- 인터페이스를 이용한 다형성
  - 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있음
  - 인터페이스 타입으로의 형변환도 가능
    - 예시
    ```agsl
    Fightbale f = (Fightanle) new Fighter();
    or
    Fightable f = new Fighter();
    ```
  - 메서드의 매개변수의 타입으로도 사용
    - 예시
    ```agsl
    void attack(Fightable f){
    }    
    ```
  - 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것 역시 가능
    - 예시
    ```agsl
    Fightable method(){
        return new Fighter();
    }
    ```
    - 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미
    - 분산환경 프로그래밍에 사용하기 좋음
      - 사용자 컴퓨터에 설치된 프로그램을 변경하지 않고 서버측의 변경만으로도 사용자가 새로 개정된 프로그램을 사용하는 것이 가능
- 인터페이스의 장점
  1. 개발시간을 단축시킬 수 있음
     - 인터페이스가 작성되면, 이를 사용해 프로그램 작성 가능
     - 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 되기 때문
     - 동시에 다른 한쪽에서는 인터페이스를 구현하는 클래스를 작성하도록 하여, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 동시 개발 진행 가능
  2. 표준화 가능
     - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램 개발 가능
  3. 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음
     - 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있음
  4. 독립적인 프로그래밍 가능
     - 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능
     - 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍 가능
  - 자바에는 다수의 데이터베이스 관련된 다수의 인터페이스를 제공하고 있으며, 프로그래머는 이 인터페이스를 이용해서 프로그래밍하면 특정 데이터베이스에 종속되지 않는 프로그램을 작성할 수 있음
- 인터페이스의 이해
  - 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있음
  - 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 됨

### ❗ 회독
|  1회독  | 2회독  | 3회독  | 4회독  |  5회독  |
|:-----:|:----:|:----:|:----:|:-----:|
|   ⭕   |