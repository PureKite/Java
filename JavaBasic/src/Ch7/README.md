## 객체지향 프로그래밍2

---
### ❓ 상속(inheritance)
- 상속의 정의와 장점
  - 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
  - 상속을 통해 클래스를 작성하면 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이
    - 즉, 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여
  - 자바에서 상속을 구현하는 방법
    - 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 씀
    ```agsl
    class Child extends Parent{
        // ...
    }
    ```
  - 조상 클래스 : 부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스
  - 자손 클래스 : 자식(child) 클래스, 하위(sub) 클래스, 파생된(derived) 클래스
  - 상속계층도(class hierarchy) : 클래스 간의 상속관계를 그림으로 표현한 것(p.223 참고)
  - 자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 가짐
    - 즉, 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나게 된다.
  - 상속을 받는다는 것 = 조상 클래스를 확장(extend)한다는 의미로 해석 가능
  - 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속됨
  - 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많음
  - 클래스 간의 관계에서 형재 관계와 같은 것은 없음. 부모와 자식의 관계(상속 관계)만이 존재
  - 조상 클래스만 변경해도 모든 자손 클래스에, 자손의 자손 클래스에까지 영향을 미치기 때문에, 클래스간의 상속관계를 맺어 주면 클래스들의 공통적인 부분은 조상 클래스에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리하면 됨
    - 즉, 각 클래스의 코드가 적어져서 관리가 쉬워짐
      - 코드의 중복이 많아지면 유지보수가 어려워지고 일관성을 유지하기 어려움
  - 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성
- 클래스간의 관계 - 포함관계
  - 상속이외에도 클래스를 재사용하는 또 다른 방법 : 클래스 간에 '포함(Composite)관계'를 맺어 주는 것
    - 클래스 간에 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
  ```agsl
  class Point{
    int x;
    int y;
  }
  class Circle{
    Point c = new Point(); 
    int r;
  }
  ```
    - 한 클래스를 작성하는 데 다른 클래스를 멤버변수로 정의하여 포함시키는 것
  - 하나의 거대한 클래스를 작성하는 거보다 단위별로 여러 개의 클래스를 작성한 다음, 단위 클래스들을 포홤관계로 재사용
- 클래스간의 관계 결정하기
  - 상속관계 : '~은 ~이다.(is-a)'
  - 포홤관계 : '~은 ~을 가지고 있다.(has-a)'
- 단일상속(single inheritance)
  - 하나 이상의 클래스로부터 상속을 받을 수 없음
    - C++에서는 여러 클래스로부터 상속받는 다중상속을 허용하지만 자바에서는 단일 상속만을 허용하기 때문에
    - 다중상속 장점
      - 다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성
    - 다중상속 단점
      - 클래스간의 관계가 매우 복잡해짐
      - 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 없음
- Object클래스 - 모든 클래스의 조상
  - 모든 상속계층도의 최상의위에는 Object클래스가 위치  
    - Object클래스는 모든 클래스 상속계층도의 제일 위에 위치하는 조상클래스
    - 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함
  - 자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있음
    - toString(), equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용할 수 있었던 이유

### ❓ 오버라이딩(overriding)
- 오버라이딩이란?
  - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
    - 자손 클래스 자신에 맞게 변경해야하는 경우
  ```agsl
  class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x :" + x + ", y : " + y;
    }
  }
   class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        return "x :" + x + ", y : " + y + ", z : " + z;
    }
  }
  ```
- 오버라이딩의 조건
  - 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야함
    - 이름이 같아야 함
    - 매개변수가 같아야 함
    - 리턴타입이 같아야함
  - 접근 제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경 가능
    1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 가능
       - 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야함
       - 대부분의 경우 같은 범위의 접근 제어자 사용
       - 접근 제어자의 접근범위를 넓은 것에서 좁은 것 순으로 나열
         - public, protected, (default), private
    2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
       - 주의할 점 : 단순히 선언된 예외의 개수의 문제가 아님
         - Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있음
  - 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없음
- 오버로딩 vs 오버라이딩
  - 오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new)
  - 오버라이딩(overriding) : 상속받은 메서드의 내용을 변경하는 것(change, modify)
- super
  - 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
  - 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때는 super를 사용해서 구별
  - 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고 super와 this는 근본적으로 같음
  - 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 됨
    - static메서드(클래스메서드)는 인스턴스와 관련이 없음 => this와 마찬가지로 static메서드에서는 사용할 수 없음
  - 변수만이 아니라 메서드 역시 super를 써서 호출 가능
  - 특히 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에 super 사용
  ```agsl
  class Point{
    int x;
    int y;
    
    String getLocation(){
        return "x :" + x + ", y : " + y;
    }
  }
   class Point3D extends Point{
    int z;
    
    String getLocation(){ //오버라이딩
        // return "x :" + x + ", y : " + y + ", z : " + z;
        return super.getLocation() + ",z :" + z; // 조상의 메서드 호출 
    }
  }
- super() - 조상 클래스의 생성자
  - this()와 마찬가지로 super() 역시 생성자
  - this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용
  - 자손 클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스 생성
    - 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것
  - 조상 클래스 멤버의 생성과 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 함
  - 생성자의 첫 줄에서 조상클래스의 생성자를 호출해야하는 이유
    - 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야함
  - 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복
    - 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object()까지 가서야 끝이 남
    - Object클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야함
      - 그렇지 않으면 컴파일러는 생성자의 첫 줄에 'super();'를 자동적으로 추가
  - 인스턴스를 생성할 때는 클래스를 선택하는 것만큼 생성자를 선택하는 것도 중요한 일
    1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
    2. 생성자 - 선택한 클래스의 어떤 생성자를 이용해서 인스턴스를 생성할 것인가?

### ❓ package와 import
- package
  - 패키지란 클래스의 묶음
  - 패키지에는 클래스 또는 인터페이스를 포함 시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리
  - 같은 이름의 클래스일지라도 서로 다른 패키지에 존재하는 것이 가능
  - 자신만의 패키지 체계를 유지함으로써 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있음
  - 클래스가 물리적으로 하나의 클래스파일(.class)인 것과 같이 패키지는 물리적으로 하나의 디렉토리
  - 디렉토리가 하위 디렉토리를 가질 수 있는 것처럼, 패키지도 다른 패키지를 포함할 수 있으며 점 '.'으로 구분
    - 점(.)을 구분자로 하여 계층구조 구성
- 패키지의 선언
  - package 패키지명;
  - 하나의 소스파일에서 주석과 공백을 제외한 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용
  - 모든 클래스는 반드시 하나의 패키지에 속해야함
  - 패키지를 선언하지 않고도 아무런 문제가 없었던 이유는?
    - 자바에서 기본적으로 제공하는 '이름없는 패키지(unnamed package)' 때문
  - 패키지의 루트 디렉토리
    - 클래스패츠(classpath)
- import
  - 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것
  - 컴파일 시에 컴파일러는 import문을 통해 소스파일에 사용된 클래스들의 패키지를 알아 낸 다음, 모든 클래스이름 앞에 패키지명을 붙여줌
  - import문은 프로그램의 성능에 전혀 영향을 미치지않음
    - import문을 많이 사용함녀 컴파일 시간이 아주 조금 더 걸릴 뿐
- import문의 선언
  - 모든 소스파일(.java)에서 import문은 package문 다음에, 그리고 클래스 선언 문 이전에 위치
    1. package문
    2. import문
    3. 클래스 선언
  - import문을 선언하는 방법
    - import 패키지명.클래스명;
    - import 패키지명.*;
  - 같은 패키지에서 여러 개의 클래스가 사용될 때, import문을 여러 번사용하는 대신 '패키지명.*'을 이용해 지정된 패키지에 속하는 모든 클래스를 패키지명 없이 사용할 수 있음
    - 실행 시 성능상의 차이는 전혀 없음
    - import하는 패키지의 수가 많을 때는 어느 클래스가 어느 패키지에 속하는지 구별하기 어렵다는 단점
    - 클래스의 이름 대신 *를 사용하는 것이 하위 패키지의 클래스까지 포함하는 것은 아님
      - 얘) import java.util.*; import java.text.*; => import java.*;X
  - import문으로 패키지를 지정하지 않으면 모든 클래스이름 앞에 패키지명을 반드시 붙여야함



### ❗ 회독
|  1회독  | 2회독  | 3회독  | 4회독  |  5회독  |
|:-----:|:----:|:----:|:----:|:-----:|
|   ⭕   |