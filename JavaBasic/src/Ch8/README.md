## 예외처리(exception handling)

---
### ❓ 프로그램 오류
- 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우 => 프로그램 에러 또는 오류
- '컴파일 에러' : 컴파일 할 때 발생하는 에러
- '런타임 에러' : 프로그램의 실행도중에 발생하는 에러
- 소스코드를 컴파일 하면 컴파일러가 소스코드(*.java)에 대한 오타나 잘못된 구문, 자료형 체크 등의 기본적인 검사 수행 후 오류 알림
  -> 컴파일러가 알려준 에러 모두 수정해서 컴파일 성공 -> 클래스 파일(*.class) 생성 -> 실행
- 컴파일을 에러없이 성공적으로 마쳤다고 해도 프로그램의 실행 시에도 에러 발생할 수 있음
- 런타임 에러를 방지하기 위해서는 프로그램의 실행도중 발생할 수 있는 모든 경우의 수 고려하여 대비
- 자바에서는 실행 시(runtime) 발생할 수 있는 프로그램 오류 - 에러(error), 예외(exception)으로 구분
- 에러 : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
  - 메모리 부족(OutOfMemoryError), 스택오버플로우(StackOverflowError) 등
- 예외 : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
- 에러가 발생하면 프로그램의 비정상적인 종료를 막을 수 없지만, 예외는 발생하더라도 미리 적절한 코드를 통해 막을 수 있음

### ❓ 예외처리의 정의 목적
- 예외처리(exception handling) : 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것
- 목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것

### ❓ 예외처리구문 : try-catch
- 예외를 처리하기 위한 구문 : try-catch문 사용
- 구조
  ```agsl
  try{
    // 예외가 발생할 가능성이 있는 문장 삽입
  }catch(예외){
    // 예외가 발생했을 경우 처리하는 문장 적기
  }
  ```
- 하나의 try블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch블럭이 올 수 있음
  - 이 중 발생한 예외의 종류와 일치하는 단 한개의 catch블럭만 수행
- 발생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않음
- catch블럭 내에 또 하나의 try-catch문이 포함된 경우, 같은 이름의 참조변수를 사용해서는 안됨
  - 각 catch블럭에 선언된 두 참조변수의 영역이 서로 겹치기 때문에 다른 이름을 사용해서 구별

### ❓ try-catch문에서의 흐름
- try블럭 내에서 예외가 발생한 경우
  1. 발생한 예외와 일치하는 catch블럭이 있는지 확인
  2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행
  3. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못함
- try블럭 내에서 예외가 발생하지 않은 경우
  1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행 계속

### ❓ 예외 발생시키기
- 키워드 throws를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있음
- 방법
  1. 먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만듦
     - Exception e = new Exception(""");
  2. 키워드 throw를 이용해서 예외 발생시킴
     - throw e;

### ❓ 예외 클래스의 계층구조
- 자바에서는 실행 시 발생할 수 있는 오류(Exception과 Error)를 클래스로 정의
- Exception과 Error 클래스 모두 Object클래스의 자손들
- 모든 예외의 최고 조상은 Exception클래스
- 예외 클래스들을 두 개의 그룹으로 나눌 수 있음
  - RuntimeException클래스와 그 자손클래스들
  - Exception클래스와 그 자손클래스들
- RuntimeException 클래스
  - 프로그래머의 실수에 의해 발생될 수 있는 얘외들
  - 자바의 프로그래밍 요소들과 관계가 깊음
  - 예
    - 배열의 범위를 벗어남 - IndexOutOfBoundsException
    - 값이 null인 참조변수의 멤버 호출 - NullPointerException
    - 클래스간의 형변환 잘못 - ClassCastException
    - 정수를 0으로 나눔 - ArithmeticException
  - try-catch문을 사용하기보다는 예외가 일어나지 않도록 프로그램을 변경하는 것이 바른 처리방법
- Exception클래스
  - 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
  - 프로그램의 사용자들의 동작에 의해서 발생하는 경우
  - 예
    - 존재하지 않는 파일의 이름을 입력 - FileNotFoundException
    - 실수로 클래스의 이름을 잘못 적음 - ClassNotFoundException
    - 입력한 데이터 형식이 잘못됨 - DataFormatException
  - 이런 종류의 예외들은 반드시 처리해줘야함

### ❓ 예외의 발생과 catch블럭
- catch블럭은 괄호()와 블럭{} 두 부분으로 나눠져 있는데, 괄호()내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언해야함
- 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어 짐
- 예외가 발생한 문장이 try-catch문의 try블럭에 포함되어 있다면, 이 예외를 처리할 수 있는 catch블럭이 있는지 찾게 됨
- 첫 번째 catch블럭부터 차례로 내려가면서 catch블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스에 instanceof연산자를 이용해서 검사결과가 true인 catch블럭을 만날 때까지 검사
- 검사결과가 true인 catch블럭을 찾게 되면 블럭에 있는 문장들을 모두 수행한 후에 try-catch문을 빠져나가고 예외는 처리되지만, 검사결과가 true인 catch블럭이 하나도 없으면 예외는 처리되지 않음
- 모든 예외 클래스는 Exception클래스의 자손, catch블럭의 괄호()에 Exception클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch블럭에 의해 처리
- 예외가 발생했을 때 생성되는 예외클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨져 있음
  - printStackTrace() : 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력
  - getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있음
  - 발생한 예외에 대한 정보를 파일에 저장 가능

### ❓ finally 블럭
- try-catch문과 함께 예외에 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용
- 방법
  ```agsl
  try{
    // 예외 발생 가능성 문장
  }catch(Exception1 e1){
    // 예외처리를 위한 문장 적기
  }finally{
    // 예외의 발생여부에 관계없이 항상 수행되어야하는 문장 넣기
    // finally블럭은 try-catch문의 맨 마지막에 위치
  }
  ```
- 예외가 발생한 경우 : try -> catch -> finally
- 예외가 발생하지 않는 경우 : try -> finally
- return문이 실행되는 경우에도 finally블럭의 문장들이 먼저 실행된 후에, 현재 실행 중인 메서드 종료

### ❓ 메서드에 예외 선언하기
- 예외를 메서드에 선언하는 방법
  - 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 얘외 적어주기
    - 예외가 여러개일 경우에는 쉼표(,)로 구분
    - void method() throws Exception1, Exception2, ... ExceptionN{}
- 메서드의 선언부에 예외를 선언함으로써 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때, 이 메서드를 사용하기 위해서는 어떠한 예외들이 처리되어져야 하는지 쉽게 알 수 있음
- 자바에서는 메서드를 작성할 때 메서드 내에서 발생할 가능성이 있는 얘외를 메서드의 선언부에 명시하여 이 메서드를 사용하는 쪽에서 이에 대한 처리를 하도록 강요
  - 견고한 프로그램 코드 작성에 도움을 줌
- 예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것
- 예외가 발생한 메서드 내에서 자체적으로 처래해도 되는 것 => 메서드 내에서 try-catch문을 사용해서 처리
- 메서드 내에서 자체적으로 해결이 안 되는 경우 => 예외를 메서드에 선언해서, 호출한 메서드에서 처리

### ❓ 예외 되던지기(exception re-throwing)
- 예외 되던지기 : 예외를 처리한 후에 인위적으로 다시 발생시키는 방법
- 예외가 발생할 가능성이 있는 메서드에서 try-catch문을 사용해서 예외를 처리해주고 catch문에서 필요한 작업을 행한 후에 throw문에 사용해서 예외를 다시 발생
- 다시 발생한 예외는 이 메서드를 호출한 메서드에게 전달되고 호출된 메서드와 try-catch문에서 예외를 또다시 처리
- 하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용
- 주의해야할 점 : 예외가 발생한 메서드에서는 try-catch문을 사용해서 예외처리를 해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다는 것

### ❓ 사용자정의 예외 만들기
- 기존의 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있음
- 보통 Exception클래스로부터 상속받는 클래스를 만들지만, 필요에 따라 알맞은 예외 클래스를 선택
- 예
  ```agsl
  class MyException extends Exception{
    MyException(String msg){ // 문자열을 매개변수로 받는 생성자
        super(msg); // 조상인 Exception클래스의 생성자를 호출
    }
  }
  ```



### ❗ 회독
|  1회독  | 2회독  | 3회독  | 4회독  |  5회독  |
|:-----:|:----:|:----:|:----:|:-----:|
|   ⭕   |