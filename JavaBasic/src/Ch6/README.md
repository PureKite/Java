## 객체지향 프로그래밍1

---
### ❓ 객체지향언어
- 객체지향언어의 역사
  - 모의실험을 위해 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력하였으며 이러한 노력은 객체지향이론을 탄생시킴
  - 객체지향이론의 기본 개념 : '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'
  - 객체지향이론은 상속, 캡슐화, 추상화 개념을 중심으로 점차 구체적으로 발전
  - 자바가 1995년에 발표되고 1990년대 말에 인터넷의 발전과 함께 크게 유행하면서 객체지향언어는 이제 프로그래밍언어의 주류로 자리 잡았다.
- 객체지향언어
  - 기존의 프로그래밍언어와 다른 전혀 새로운 것이 아니라, 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전한 형태의 것
  - 이러한 규칙들을 이용해서 코드 간에 서로 관계를 맺어 줌으로써 보다 유기적으로 프로그램을 구성하는 것이 가능
  - 객체지향언어의 주요 특징
    ```agsl
    1. 코드의 재사용성이 높다.
      - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있음
    2. 코드의 관리가 용이하다.
      - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있음
    3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
      - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지
    ```
  - 가장 큰 장점 : 코드의 재사용성이 높고 유지보수가 용이
  - 상속, 다형성 같은 객체지향개념을 학습할 때 재사용성과 유지보수 그리고 코드의 중복 제거, 이 세 가지 관점에서 보면 보다 쉽게 이해할 수 있음
  - 일단 프로그램을 기능적으로 완성한다음 어떻게하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해 나가는 것이 좋음
    - 이러한 경험들이 축적되어야 프로그램을 객체지향적으로 설계할 수 있는 능력이 길러지는 것

### ❓ 클래스와 객체
- 클래스와 객체의 정의와 용도
  ```agsl
  클래스의 정의 - 클래스란 객체를 정의해 놓은 것
  클래스의 용도 - 클래스는 객체를 생성하는데 사용
  ```
  ```agsl
  객체의 정의 - 실제로 존재하는 것, 사물 또는 개념
  객체의 용도 - 객체가 가지고 있는 기능과 속성에 따른 다름
  
  유형의 객체 - 책상, 의자, 자동차, TV와 같은 사물
  무형의 객체 - 수학공식, 프로그램 에러와 같은 논리나 개념
  
  프로그래밍에서의 객체 : 클래스에 정의된 내용대로 메모리에 생성된 것
  ```
  - 예) 클래스 - 객체 : 제품 설계도(TV 설계도) - 제품(TV)
  - 클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아님
  - 우리가 원하는 기능의 객체를 사용하기 위해서는 먼저 클래스로부터 객체를 생성하는 과정이 선행되어야 함
    - 예) TV를 보기 위해서는 TV(객체)가 필요할 뿐, TV 설계도(클래스)가 필요하지 않음 => TV 설계도는 단지 TV라는 제품을 만드는 데만 사용될 뿐
  - 클래스를 한번만 잘 만들어 놓기만 하면, 매번 객체를 생성할 때마다 어떻게 객체를 만들어야 할지를 고민하지 않아도 된다.
  - 그냥 클래스로부터 객체를 생성하서 사용하기만 하면 되는 것
  - JDK(Java Development Kit)에서는 프로그래밍을 위해 많은 수의 유용한 클래스(Java API)를 기본적으로 제공하고 있으며, 우리는 이 클래스들을 이용해서 원하는 기능의 프로그램을 보다 쉽게 작성할 수 있음
- 객체와 인스턴스
  - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)
  - 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)
  - 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미
  - 클래스 -> 인스턴스화 -> 인스턴스
  - 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야함
- 객체의 구성요소 - 속성과 기능
  - 객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있으며, 일반적으로 객체는 다수의 속성과 다수의 기능을 가짐
    - 즉, 객체는 속성과 기능의 집합
  - 객체가 가지고 있는 속성과 기능을 그 객체의 멤버(구성원, member)라고 함
  - 클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어 있음
  - 클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어지는 것
  ```agsl
  속성(property) - 멤버변수(membervariable), 특성(attribute), 필드(field), 상태(state)
  기능(function) - 메서드(method), 행위(behavior), 함수(function)
  ```
  ```
  속성(property) -> 멤버변수(variable)
  기능(function) -> 메서드(method)
  
  채널 -> int channel
  채널 높이기 -> channelUp(){ ... }
  ``` 
- 인스턴스의 생성과 사용
  ```agsl
  클래스명 변수명; // 클래스의 객체를 참조하기 위한 첨조변수를 선언
  변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
  
  Tv t; // Tv클래스 타입의 참조변수 t를 선언
  t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
  
  t1.channel // 참조변수.멤버변수
  ```
  - 참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는 것은 가능
  - 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능하지 않음
- 클래스의 또 다른 정의
  - 클래스 - 데이터와 함수의 결합
    - 프로그래밍언어에서 데이터 처리를 위한 저장형태의 발전과정
      ```agsl
      1. 변수 - 하나의 데이터를 저장할 수 있는 공간
      2. 배열 - 같은 종료의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
      3. 구조체 - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
      4. 클래스 - 데이터와 함수의 결합(구조체 + 함수)
      ```
  - 클래스 - 사용자정의 타입(user-defined type)
    - 사용자정의 타입이란?
      - 프로그래밍언어에서 제공하는 자료형 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것
    - 객체지향언어에서는 클래스가 곧 사용자 정의 타입

### ❓ 변수와 메서드
- 선언위치에 따른 변수의 종류
  - 변수 : 클래스변수, 인스턴스변수, 지역변수
  1. 인스턴스변수(instance variable)
     - 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어짐
     - 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야함
     - 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있음
     - 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스변수로 선언
  2. 클래스변수(class variable)
     - 클래스 영역에 선언되며, 클래스가 메모리에 올라갈 때 만들어짐
     - 클래스 변수를 선언하는 방법은 인스턴스변수 앞에 static을 붙이기만 하면 됨
     - 클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 됨
       - 클래스 변수를 공유 변수라고도 함
     - 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스변수로 선언해야함
     - 인스턴스변수는 인스턴스를 생성한 후에야 사용가능하지만, 클래스 변수는 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다는 특징이 있음
       - '클래스이름.클래스변수' 형식으로 사용
     - 클래스가 로딩될 때 생성되어 프로그램이 종료될 때 까지 유지되며, public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수의 성격을 가짐
  3. 지역변수(local variable)
     - 메서드 내에 선언되어 메서드 내에서만 사용 가능
     - 메서드가 종료되면 소멸되어 사용할 수 없게 됨
     - for문 또는 while문의 블럭 내에 선언된 지역변수는 지역변수가 선언된 블럭{}내에서만 사용 가능하며, 블럭{}을 벗어나며 소멸되어 사용할 수 없음
  - 클래스변수와 인스턴스변수
    - 예제
      ```agsl
      class Card{
        String kind; // 카드의 무늬 - 인스턴스변수
        int number;  // 카드의 숫자 - 인스턴스변수
        static int width = 100; // 카드의 폭 - 클래스변수
        static int height = 250; // 카드의 높이 - 클래스변수
      }
      ```
    - 인스턴스변수는 인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만,
    - 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 가짐
- 메서드
  - 어떤 작업을 수행하기 위한 명령문의 집합
  - 주로 어떤 값을 입력받아서 처리하고 그 결과를 되돌려 줌.
    - 경우에 따라서는 입력받는 값이 없을 수도 있고 결과를 반환하지 않을 수도 있다.
  - 메서드를 작성하는 이유
    - 반복적으로 사용되는 코드를 줄이기 위해서
      - 자주 사용되는 내용의 코드를 메서드로 작성해 놓고 필요한 곳에서 호출
    - 코드의 양도 줄일 수 있고 코드를 한 곳에서만 관리하면 되므로 유지보수가 편리
    ```agsl
    - 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋다.
    - 반복적으로 수행되어야 하는 여러 문장을 하나의 메서드로 정의해 놓으면 좋다.
    - 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다.
    ```
  - 메서드를 작성하는 방법
    - 메서드는 크게 선언부와 구현부(몸통, body)로 나누어져 있음
    ```agsl
    리턴타입 메서드이름(타입 변수명, 타입 변수명, ...) // 선언부
    { 
        //메서드 호출시 수행될 코드
    } // 구현부
    
    예제1
    int add(int a, int b)
    {
        int result = a + b;
        return result;
    }
    
    예제2) 반환값이 없는 경우 리턴타입 대신 void를 사용한다.
    void power(){
        power = !power;
    }
    ```
    - 메서드의 괄호()에 선언된 매개변수는 지역변수로 간주되어 메서드 내에서만 사용될 수 있으며, 메서드가 종료되는 순간 메모리에서 제거되어 더 이상 사용할 수 없음
    - 메서드가 결과갑을 반환하는 경우에는 메서드 내에 반드시 return문을 사용해서 리턴타입에 맞는 결과값을 호출한 메서드에게 반환
- return문
  - 메서드가 정상적으로 종료되는 경우
    ```agsl
    - 메서드의 블럭{}내의 마지막 문장까지 수행했을 때
    - 메서드의 블럭{}내에 있는 문장을 수행 중 return문을 만났을 때
    ```
  - return문은 현재 실행 중인 메서드를 종료하고 호출한 메서드로 되돌아감
    1. 반환값이 없는 경우 - return문만 써주면 됨
    2. 반환값이 있는 경우 - return문 뒤에 반환값을 지정해 주어야 함
      - 반환값은 메서드의 선언부에 정의된 반환타입과 일치하거나 반환타입으로 자동형변환이 가능한 것
  - 메서드 내에서 return문을 여러 번 쓰는 것보다 가능하면 변수를 사용해서 리턴값을 저장했다가 마지막에 한 번만 사용하는 것이 좋음
- 메서드의 호출
  - 메서드를 호출하는 방법
    ```agsl
    참조변수.메서드이름(); // 메서드에 선언된 매개변수가 없는 경우
    참조변수.메서드이름(값1, 값2, ...); // 메서드에 선언된 매개변수가 있는 경우
    ```
  - 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없음
  - 호출 시에 입력된 값은 메서드의 매개변수에 대입되는 값
- JVM의 메모리구조
  - 3가지 주요영역(174p 그림 참고)
    1. 메서드영역(method area)
       - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장
       - 이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성
    2. 힙(heap)
       - 인스턴스가 생성되는 공간
       - 프로그램 싱행 중 생성되는 인스턴스는 모두 이곳에 생성
       - 인스턴스변수(instance variable)들이 생성되는 공간
    3. 호출스택(call stack 또는 execution stack)
       - 메서드의 작업에 필요한 메모리 공간 제공
       - 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용
       - 메서드가 작업을 마치면 할당되었던 메모리공간을 반환되어 비워짐
  - 각 메서드를 위한 메모리상의 작업공간은 서로 구별
  - 호출스택의 제일 상위에 위차하는 메서드가 현재 실행 중인 메서드이며, 나머지는 대기상태에 있게 됨
  - 호출스택을 조사해보면 메서드 간의 호출관계와 현재 수행중인 메서드가 어느 것인지 알 수 있음
  - 호출스택의 특징
    - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받음
    - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거
    - 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드
  - 반환타입(return type)이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드(caller)에게 반환
  - 대기상태에 있던 호출한 메서드(caller)는 넘겨받은 반환값으로 수행을 계속 진행
- 기본형 매개변수와 참조형 매개변수
  - 자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨줌
  - 매개변수의 타입이 기본형(primitive type)일 때는 기본형 값이 복사되겠지만 참조형(reference type)이면 인스턴스의 주소가 복사
  ```agsl
  기본형 매개변수 - 변수의 값을 읽기만 할 수 있음(read only)
  참조형 매개변수 - 변수의 값을 읽고 변경할 수 있음(read & write)
  ```
- 재귀호출(recursive call)
  - 메서드의 내부에서 메서드 자기 자신을 다시 호출하는 것
  - 반복적인 작업을 해야 하는 메서드에 반복문 대신 재귀호출을 이용하면, 메서드를 훨씬 간단하게 할 수 있는 경우
  - 다소 효율이 떨어진다는 단점 => 반복적으로 메서드를 호출하는 것이기 때문에 메서드를 호출하는데 드는 비용이 추가적으로 발생
  - 호출스택의 메모리 한계를 넘게 되었을 때 => StackOverflowError 발생
- 클래스메서드(static메서드)와 인스턴스메서드
  - 메서드 앞에 static이 붙어 있으면 클래스메서드이고 붙어 있지 않으면 인스턴스메서드
  - 클래스메서드도 클래스변수처럼, 객체를 생성하지 않고도 '클래스이름.메서드이름(매개변수)' 호출 가능
  - 인스턴스메서드는 반드시 객체를 생성해야만 호출
  - 어느 경우에 static을 사용해서 클래스메서드로 정의해야하는 것일까?
    - 인스턴스메서드는 인스턴스변수와 관련된 작업을 하는 즉 메서드의 작업을 수행하는데 인스턴스변수를 필요로 하는 메서드
    - 인스턴스와 관계없는(인스턴스변수나 인스턴스메서드를 사용하지 않는) 메서드를 클래스메서드(static메서드)로 정의
  1. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
     - 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지
     - 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의
  2. 클래스변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있음
     - static이 붙은 변수(클래스변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문
  3. 클래스메서드(static메서드)는 인스턴스변수를 사용할 수 없음
     - static이 붙은 메서드는 인스턴스 생성 없이 호출가능한 반면, 인스턴스변수는 인스턴스를 생성해야만 만들어지기 때문에 static이 붙은 메서드(클래스메서드)를 호출할 때 인스터스가 생성되어있지 않을 수 있어서 static이 붙은 메서드에서 인스턴스변수의 사용을 허용하지 않음
     - 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능
       - 인스턴스변수가 존재한다는 것은 static이 붙은 변수가 이미 메모리에 존재한다는 것을 의미하기 때문
  4. 메서드 내에서 인스턴스변수를 사용하지 않는다면, static을 붙이는 것을 고려
     - 메서드의 작업내용 중에서 인스턴스변수를 필요로 한다면, static을 붙일 수 없음
     - 인스턴스변수를 필요로 하지 않는다면 static을 붙이는 것이 좋음
       - 메서드 호출시간이 짧아지기 때문에 효율이 높아짐
     - static을 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸림
- 클래스멤버와 인스턴스멤버간의 참조와 호출
  - 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출 가능
  - 클래스멤버가 인스턴스멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 함
    - 인스턴스멤버가 존재하는 시점에 클래스멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스멤버가 존재할 수도 있고 존재하지 않을 수도 있기 때문
  - 인스턴스멤버간의 호출에는 아무런 문제가 없음
    - 하나의 인스턴스멤버가 존재한다는 것은 인스턴스가 이미 생성되어있다는 것을 의미하며, 즉 다른 인스턴스멤버들도 모두 존재하기 때문

### ❓ 메서드 오버로딩(method overloading)
- 메서드 오버로딩이란?
  - 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩(method overloading) or 오버로딩(overloading)
  - 보통 하나의 메서드 이름에 하나의 기능만을 구현해야하는데, 하나의 메서드 이름으로 여러 기능을 구현하기 때문에 붙여진 이름
- 오버로딩의 조건
  1. 메서드 이름이 같아야 함
  2. 매개변수의 개수 또는 타입이 달라야 함
  3. 매개변수는 같고 리턴타입이 다른 경우는 오버로딩이 성립되지 않음
     - 리턴타입은 오버로딩을 구현하는데 아무런 영향을 주지 못함
  - 위의 조건을 만족시키지 못하는 메서드는 중복정의된 것으로 간주되어 컴파일 시에 에러가 발생
- 오버로딩의 예
  - 대표적인 것은 println메서드
  - 성립 x
    - 매개변수의 이름만 다를 뿐 매개변수의 타입이 같음
        ```
        int add(int a, int b){return a + b;}
        int add(int x, int y){return x + y;}
        ```
    - 리턴타입만 다른 경우
        ```
        int add(int a, int b){return a + b;}
        long add(int a, int b){return (long) (a + b);}
        ```
  - 성립 O
    - 호출 시 매개변수의 값에 의해 호출될 메서드가 구분될 수 있음
        ```
        long add(int a, int b){return a + b;}
        long add(long a, long b){return a + b;}
        ```
- 오버로딩의 장점
  - 오버로딩을 통해 여러 메서드들이 하나의 이름으로 정의될 수 있음 => 메서드의 이름을 절약할 수 있음
    - 기억하기도 쉽고 이름도 짧게 할 수 있어서 오류의 가능성을 많이 줄일 수 있음
    - 메서드의 이름만 보고도 기능을 쉽게 예측 가능
    - 메서드의 이름을 짓는데 고민을 덜 수 있음

### ❓ 생성자(Constructor)
- 생성자란?
  - 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'
  - 인스턴스변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용됨
  - 생성자 역시 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만 리턴값이 없다는 점이 다름
  - 생성자 앞에 리턴값이 없을을 뜻하는 키워드 void를 사용하지는 않고 단지 아무것도 적지 않음
  - 생성자의 조건
    1. 생성자의 이름은 클래스의 이름과 같아야 함
    2. 생성자는 리턴 값이 없음
  - 생성자 정의
    ```agsl
    클래스이름(타입 변수명, 타입 변수명, ...){
        // 인스턴스 생성 시 수행될 코드
        // 주로 인스턴스 변수의 초기화 코드를 적음
    }
    class Card{
        Card(){  // 매개변수가 없는 생성자
            // ...
        }
        Card(String k, int num){ // 매개변수가 있는 생성자
            //...
        }
    }
    
    Card클래스의 인스턴스를 생성하는 코드 예
    Card c = new Card();
    1. 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스 생성
    2. 생성자 Card()가 호출되어 수행
    3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장
    ```
  - 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것은 아님
  - 인스턴스를 생성하기 위해 사용해왔던 '클래스이름()'이 바로 생성자
  - 인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선택하여 지정해주어야 함
- 기본 생성자(default constructor)
  - 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 기본 생성자 덕분
  - 컴파일 할 때, "소스파일(*.java)의 클래스에 생성자가 하나도 정의되지 않은 경우" 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일
  - 형식
    - 클래스이름() {}
    - ex) Card() {}
    - 클래스의 접근 제어자가 public인 경우
      - public 클래스이름() {}
  - 인스턴스 초기화 작업이 요구되지 않는다면 생성자를 정의하지 않고 컴파일러가 제공하는 기본 생성자를 사용
- 매개변수가 있는 생성자
  - 생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용할 수 있음
  ```agsl
  class Car{
    String color;
    String gearType;
    int door;
    
    Car(){} // 생성자
    Car(String c, String g, int d){
        color = c;
        gearType = g;
        door = d;
    }
  }
  ```
- 생성자에서 다른 생성자 호출하기 - this(), this
  - 생성자 간에도 서로 호출 가능
  - 다음의 조건을 만족
    - 생성자의 이름으로 클래스이름 대신 this를 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능
  ```agsl
  Car(){
    this("white", "auto", 4);
  }
  ```
  - 같은 클래스 내의 생성자들은 일반적으로 서로 관계가 깊은 경우가 많아서 이처럼 서로 호출하도록 하여 유기적으로 연결해주면 더 좋은 코드를 얻을 수 있음
  - 수정이 필요한 경우에도 보다 적은 코드만을 변경하면 되므로 유지보수가 쉬워짐
  ```agsl
  Car(String color, String gearType, int door){
    this.color = color;
    this.gearType = gearType;
    this.door = door;
  }
  ```
  - 생성자의 매개변수로 인스턴스변수들의 초기값을 제공받는 경우가 많기 때문에 this를 사용해서 구별되도록 하는 것이 의미가 더 명확하고 이해하기 쉬움
  - this를 사용할 수 있는 것은 인스턴스멤버뿐
    - static메서드(클래스메서드)에서는 인스턴스 멤버들을 사용할 수 없는 것처럼, this 역시 사용할 수 없음
      - static메서드는 인스턴스를 생성하지 않고도 호출될 수 있으므로 static메서드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문
  ```agsl
  this - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장 / 모든 인스턴스메서드에 자신이 관련된 인스턴스를 가리키는 참조변수 this가 지역변수로 숨겨진 채로 존재
  this(), this(매개변수) - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
  ```
- 생성자를 이용한 인스턴스의 복사
  - 현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나더 만들고자 할 때 생성자 이용 가능
    - 두 인스턴스가 같은 상태를 갖는다는 것은?
      - 두 인스턴스의 모든 인스턴스변수(상태)가 동일한 값을 갖고 있다는 것
  - 하나의 클래스로부터 생성된 모든 인스턴스의 메서드와 클래스변수는 서로 동일하기 때문에 인스턴스간의 차이는, 인스턴스마다 각기 다른 값을 가질 수 있는 인스턴ㄴ스변수 뿐
  ```agsl
  Car(Car c){
    color = c.color;
    gearType = c.gearType;
    door = c.door;
  }
  ```
- 인스턴스를 생성할 때 결정사항
  1. 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
  2. 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?

### ❓ 변수의 초기화
- 변수의 초기화
  - 변수를 선언하고 처음으로 값을 저장하는 것
  - 멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지지만 지역변수는 사용하기 전에 반드시 초기화를 해야함
  - 방법
    ```agsl
    1. 명시적 초기화(explicit initialization)
    2. 생성자(constructor)
    3. 초기화 블럭(initialization block)
      - 인스턴스 초기화 블럭 : 인스턴스변수를 초기화하는데 사용
      - 클래스 초기화 블럭 : 클래스변수를 초기화하는데 사용
    ```
- 명시적 초기화(explicit initialization)
  - 변수를 선언과 동시에 초기화하는 것
  ```agsl
  class Car{
    int door = 4; // 기본형(primitive type) 변수의 초기화
    Engine e = new Engine(); // 참조형(reference type) 변수의 초기화
  }
  ```
  - 명시적 초기화가 간단하고 명료하긴 하지만 복잡한 초기화 작업이 필요할 때는 '초기화 블럭' 또는 생성자 사용
- 초기화 블럭(initialization block)
  - 종류
    - 클래스 초기화 블럭과 인스턴스 초기화 블럭
      - 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용
      - 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용
  ```
  class InitBlock{
    static{/* 클래스 초기화블럭 입니다. */}
    {/* 인스턴스 초기화블럭 입니다. */}
    // ...
  } 
  ```
  - 클래스 초기화 블럭
    - 클래스가 메모리에 처음 로딩될 때 한번만 수행
    - 클래스가 처음 로딩될 때 클래스변수들이 자동적으로 메모리에 만들어지고, 바로 클래스 초기화블럭이 클래스변수들을 초기화하게 되는 것
  - 인스턴스 초기화 블럭
    - 생성자와 같이 인스턴스를 생성할 때 마다 수행
    - 생성자보다 인스턴스 초기화 블럭이 먼저 수행
    - 인스턴스변수의 초기화는 주로 생성자 사용, 인스턴스 초기화 블럭은 잘 사용되지 않음
    - 클래스의 모든 생성자에서 공통적으로 수행되어져야 하는 코드가 있는 경우 생성자에 넣지 않고 인스턴스 초기화 블럭에 넣어 두면 코드 중복 줄일 수 있음
  - 코드의 중복을 제거하는 것은 코드의 신뢰성으 ㄹ높여 주고, 오류의 발생가능성을 줄여 줌
    - 즉, 재사용성을 높이고 중복을 제거하는 것이 객체지향프로그램이 추구하는 궁극적인 목표
- 멤버변수의 초기화 시기와 순서
  - 초기화가 수행되는 시기와 순서
  ```agsl
  클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화됨
  인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어짐
  
  클래스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
  인스턴스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자
  ```
  - 프로그램 실행도중 클래스에 대한 정보가 요구되어질 때, 클래스는 메모리에 로딩
    - 예) 클래스 멤버를 사용했을 때, 인스턴스를 생성할 때 등
    - 해당 클래스가 이미 메모리에 로딩되어 있다면, 또다시 로딩하지 않음, 초기화도 다시 수행되지 않음
  - 클래스변수는 항상 인스턴스변수보다 항상 먼저 생성되고 초기화됨
  - 초기화 과정(p.206 참고하기)


### ❗ 회독
|  1회독  | 2회독  | 3회독  | 4회독  |  5회독  |
|:-----:|:----:|:----:|:----:|:-----:|
|   ⭕   |